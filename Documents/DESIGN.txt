/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
// 12-Bit MISC CPU Design: FCH12

Harvard Architecture
    Single, Pluggable 4K ROM
    One or More 4K RAM Modules, Segmented
    Second Iteration will be a proper Stack Machine

All registers, address and data bus are 12 bits wide
All Opcodes are 6 bits with (mostly) implied operands
    2 opcodes per ROM fetch.
    Microcode sequence is: fetch-exec-exec, repeat
ROM addresses/NIP/jumps point to odd instructions
    May need to fill in NOPs here and there.
    "Big Endian" (in terms of 6-bit chars)

/////////////////////////////////////////////////////
// CPU Diagram

Machine & Bus Layout:
         ___              ___
  [CLK] |   |-[BOP]------|   \---[MCS]--\
     |  |DEC|   ||       |ALU|=\\  || \  \   _
  [INS]-|___|---||-[ACC]-|___/ ||  || |   \=| |==...
    ||       \  ||   ||        ||  || |     | |
    =========|========================|=====|C|==... 
    =========|===== DATA BUS =========|=====|P|==... 
    =========|========================|=====|U|==... 
    ||       |                     || /     | |
  [NIP]------+-------------------[PTR]      |S|
    ||                             ||       |O|
    ========================================|C|==... 
    =============== ADDR BUS ===============|K|==... 
    ========================================|E|==... 
                                            |T|
                                            |_|    

/////////////////////////////////////////////////////
// Devices Attached to Internal Main Data Bus

I    INS    INSTR WORD REG FOR DECODE (WO)
A    ACC    ALU INPUT 1 : A (ACCUMULATOR) (R/W)
B    BOP    ALU INPUT 2 : B (GP/DYADIC) (R/W)
L    ALU    ALU OUTPUT (DIRECT TO BUS) (RO)
C    MCS    MACHINE CTRL/STATUS: CARRY, CMP,
              PSEL, DSEL (R/W)
P    PTR    RAM ADDR REG (R/W) (SELECTABLE ARRAY,
              AUTO INC/DEC on R/W)
N    NIP    ROM ADDR REG (R/W) AKA NIP
S    SKT    PERIPHERAL DEVICE I/O BUS (R/W)
              12 DATA PINS, 12 ADDR PINS
                (Driven by PTR[PSEL] or NIP during FCH)
              3 DSEL PINS
                (Drive chip select on peripherals)
              2 R/W PINS
              ALSO: (GND, VDD, CLK, RST ...)

/////////////////////////////////////////////////////
// CPU socket layout:
Rough Total Pins (From ABove): 33 (div 4 = 8.25)
    Round up to 9 on a side (square chip)
    and include extra GNDs & VDDs, also
    CLK_IN/CLK_OUT
    new total = 9 x 4 = 36

    _|_|_|_|_|_|_|_|_|_
  --|                 |--
  --|                 |--
  --|                 |--
  --|                 |--
  --|      C P U      |--
  --|                 |--
  --|                 |--
  --|                 |--
  --|_________________|--
     | | | | | | | | |

Alternative Rectangular Layout
(Would keep Data Bus on one side
and Address Bus on the other)
36 - 24 = 12 , / 2 = 6

    _|_|_|_|_|_|_
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|   C P U   |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|___________|--
     | | | | | |

/////////////////////////////////////////////////////
// Inter-Device Transport Notes
ROM to INS is special case
  (Read-Only from ROM to Write-Only for INS)
ALU output is special case (Write-Only to Data Bus)
Accumulator-centric transport instructions
ACC is used for unary operations
BOP is used with ACC for duadic operations
BOP will have a bypass MUX at ALU for ops like
    INC, DEC, JCP

// Special Case Transport
INS <-- SKT     Fetch Instr. hardcoded in 18-bit INS,
                Read line overrides DSEL out to 0
                also overrides ADDR_BUS with NIP out
                NOTE: SKW with DSEL 0 is illegal
ALU --> ACC     Driven by ALU opcodes,
                Implied operands are ACC and BOP

ALU --> NIP     Cond. Relative Jump instruction JCP,
                Overrides BOP before ALU

ACC <-> SKT     RAM Read/Write or ROM Read, all
                expect manually driving DSEL
                Internal R/W lines auto drive
                INC/DEC of PTR[PSEL]

// Normal Case Transport (Simple Internal Data R/W)
ACC <-> BOP     Swap would be nice in some cases,
ACC <-> MCS     but these are all overwrite copy.
ACC <-> PTR     Writing to MCS will clear/set carry
ACC <-> NIP     and compare bits. Writing to NIP
                will also of course jump absolute!
                Writing to PTR and PSEL drives the
                address bus to ROM/RAM/(EEPROM)

/////////////////////////////////////////////////////
// TODO: 
    
Character table with ASCII conversion algorithm
Need to decide on ASCII-to-6bit char mapping
    - Possibly have 2 tables: normal and shifted
    - Or keep it simple with 1 table
    - ability to port/play Roguelike games a priority
    - in competition with ability to port Forth.

Design peripheral interfaces
    ROM expected at address 0
    RAM expected at address 1
    Graphics - Color LCD
        8080 interface. CMD/CTRL
        2 devs possible 12 bit RGB or 9bit 1 dev
    Monochrome Console LCD
        1 dev for cmd & ctrl
    Keyboard
        1 dev: 6 bit low or high char others zero
        parallel interface? look up early apple 1
    Hard Disk
    External RAM
        3 devs: 12 high addr, 12 low addr, 12 data
        2 dev: bit fields mux select, value
    Network
    Bus extender / reducer for interfacing with
        8 to 10 bit hardware: mode addr/data
        1 bus addr -- rising edge triggered
            mode select bit, data apply bit.
        2 bus addrs -- can preserve 12 bits

/////////////////////////////////////////////////////
// Main Board Peripheral Bus (8 Addresses)
// (Board Layout & Design is flexible here)

[Design A - 8K RAM with ext 12 bit peripheral bus]
0    ROM    4K ROM (RO) (PLUGGABLE CARTRIDGE)
1    RAM    4K RAM (R/W)
2    RAM    4K RAM (R/W)
3    EEPROM 512K (R/W) (Non-Volatile Storage)
4    KEYB (Parallel Interface -- TBD)
5    LCD (8080 + REGS/MODE -- TBD)
6    BUS_EXT ADDR -- Combine with Data Bus
         for 24-bit address
7    BUS_EXT DATA

[Design B - 16K RAM with ext 10 bit peripheral bus]
0    ROM    4K ROM (RO) (PLUGGABLE CARTRIDGE)
1    RAM    4K RAM (R/W)
2    RAM    4K RAM (R/W)
3    RAM    4K RAM (R/W)
4    RAM    4K RAM (R/W)
5    KEYB (Parallel Interface -- TBD)
6    LCD (8080 + REGS/MODE -- TBD)
7    BUS_EXT ADDR/DATA (2 bit mode, 10 bits data bus)
         writes:
         11xxxxxxxxxx set addr mode, apply data(addr)
         10xxxxxxxxxx set addr mode, do not apply data
         01xxxxxxxxxx set data mode, apply data(data)
         00xxxxxxxxxx set data mode, do not apply data

/////////////////////////////////////////////////////
// Instruction Design Notes

// Synthesis of other instructions:
GT and LT comparisons can be synthesized easily
MUL and DIV can be sythesized.  will never be included.

// Later Design changes:
single cycle hardware register swap or
 queue would be very useful for ptr/stack/data
also: MUX reg on RAM PTR array.  only exposes
one to the data bus.

NOTE: ROM needs to be separate and socketable.
An address bus driven by NIP and PTR is necessary,
as well as a bypass on external DSEL.
this would reduce the number of CPU pins by re-using
the address lines for ROM and RAM.  Not shown above
  are the control lines.
FCH bypasses DSEL and asserts 0 on output pins
ADDR output pins are normally driven by PTR[PSEL]
but FCH instructuon overrides this with NIP
NOTE: This also allows PTR access to ROM for reading
fonts, bitmaps, strings, etc... 
  by manually setting DSEL to 0,
  set PTR[PSEL] to desired address and executing IOR.
  This eliminates the need for LBL and frees up an
    8-block of opcodes.

NOTE: fetch opcode is avoided since this can be built
directly into the main micro cycle => drive lines.
I.E. For this "instruction" only, there nothing to
"decode" per se, just do it!

XXXXXX  N/A    FCH      INS = SKT, DSEL => 0,
                        NIP++ driven by read

N2S and S2N not really necessary as N2A,SKW and
  SKR,A2N will suffice.. although need to load contant
  into operand and premptively ADD to NIP.
  Will require selecting stack ptr

ASB swap ACC <=> BOP and save another opcode
do the same with PTR[]?  ASP?

// Instruction Trash Bin:
NOTE: Other instructions to consider:
MCS[CMP] = MCS[CAR] for testing carry in 2 instr vs 5
MCS[CMP] = ~MCS[CMP] via JK toggle (reduce #opcodes)
ZHI      ACC[HCHAR] = 0 (Debatable)
// Alternate Comparator Design (Debatable)
// More capable, More complex wiring
NCB      MCS[CMP] = ~MCS[CMP] (JK Toggle)
CCB      MCS[CMP] = MCS[CAR] (Loopback Set)
// NIX..Shifted-out bits go to MCS[RES] to facilitate
// Simulation of ROR and ROL

/////////////////////////////////////////////////////
// MCS Register Layout:

Upper two octets R/W are hardwired to ALU in/out.
In this way, the MCS resembles ACC except reversed.
writing ACC => MCS with zero in upper char clears
carry and compare bits.  ADD is always with carry.
DSEL and PSEL octets could be independent up/dn
counters to all for next/prev-dev and psel instr.
PTR[] registers may be used for temporary storage
to simulate ROR and ROL operations.  Future usage
for some reserved bits include greater/less
comparison and also signed versus unsigned
operations.

 11  10   9 | 8   7   6 | 5   4   3 | 2   1   0
[RES RES CMP|RES RES CAR|   DSEL    |   PSEL   ]

// General / Accumulator Register Layout:
 11  10   9 | 8   7   6 | 5   4   3 | 2   1   0
[ Most Sig  | Next-Most | Next-Least| Least Sig ]
[  Octet 3  |  Octet 2  |  Octet 1  |  Octet 0  ]
[  High Char (HCHAR)    |  Low Char (LCHAR)     ]

/////////////////////////////////////////////////////
// PTR[PSEL] Register Bank Behavior

One of these can be selected at any time via the PSEL
bit field in the MCS register.  The currently
selected register in the PTR[] bank drives the ADDR
bus output lines, as well as having its incrementor
and dectrementor lines connected to the decoder,
such that on socket R/W and stack R/W operations
cause the applicable in-place INC/DEC (if
applicable).  When N/A the register value remains
static unless purposefully assigned or driven by
IPT/DPT operations.

PSEL    SKW/N2S      SKR/S2N      Intended Usage

000  0  PTR[PSEL]--  PTR[PSEL]++  Return Stack
001  1  PTR[PSEL]--  PTR[PSEL]++  Data Stack
010  2  PTR[PSEL]++  N/A          Block Mem Store
011  3  N/A          PTR[PSEL]++  Block Mem Load
100  4  N/A          N/A          \
101  5  N/A          N/A          | General Purpose
110  6  N/A          N/A          | Pointer Args
111  7  N/A          N/A          / To Subroutines

// Consider storing or indicating stack sizes to
// internal data bus.  As it is, the stack size would
// have to be computed from knowing the start address
// and subtracting the current pointer address.
// This speaks to having proper hardware stacks in
// future designs.  On that note here is an alternate
// design.  Return and Data Stack pointers and size
// (0) are initialized on RESET.

// Stack Pointers and Sizes
000  0  PTR[PSEL]--  PTR[PSEL]++  Return Stack
001  1  ((Read Only Register))    Return Stack Size
010  2  PTR[PSEL]--  PTR[PSEL]++  Data Stack
011  3  ((Read Only Register))    Data Stack Size

// General Purpose / Subroutine Argument Registers
// (Arguments can be pointer or literal value,
// address bus output at socket is only enabled
// during socket read/write).
100  2  PTR[PSEL]++  N/A          Block Mem Store
101  3  N/A          PTR[PSEL]++  Block Mem Load
110  6  N/A          N/A
111  7  N/A          N/A

/////////////////////////////////////////////////////
// Opcode Table

<Bin>   <Oct>  <Mnem.>  <Descr.>

//----- 00 Group -----
// Essentials / Reserved Block / Special Transport

000000  000    HLT      Halt Execution
000001  001    RST      Reset CPU
000010  002    NOP      No Operation
000011  003    ---      RESERVED
000100  004    ---      RESERVED
000101  005    ---      RESERVED
000110  006    ---      RESERVED
000101  007    SKW      SKT = ACC, AUTO INC/DEC PTR[]
000111  003    SKR      ACC = SKT, AUTO INC/DEC PTR[]

//----- 01 Group -----
// Normal Transport Operations (Move)
// ACC Implied: 1 bit to/from, 2 bits src/dst
// Requires Argument: BOP, MCS, PTR, NIP 

0010XY  010-3  MTR      Move Accumulator To Register
                        00=BOP, 01=MCS,
                        10=PTR[PSEL], 11=NIP
                        (Absolute Jump)

0011XY  014-7  MFR      Move From Register To Accumulator
                        00=BOP, 01=MCS,
                        10=PTR[PSEL], 11=NIP
                        (Get Instr Ptr)

//----- 02 Group -----
// Literal Octet Assignment to Accumulator
// (Requires Argument: 1 through 7) 
// Left-shifts by 3 bits and loads ACC Octet 0
// ACC Octet 3 is discarded.  This is done by
// bypassing Octet 3 before the BarrelShifter
// and asserting the SH/RO line (Rotate Mode)

010XYZ  020-7  LOL      ACC Load Octet 0 with XYZ
                        Rotate ACC Left 3

//----- 03 Group -----
// Arithmetic & Logic Operations
// First two are diverted over to the BarrelShifter
// to help with loading specific values into ACC

011000  030    ROR      ACC Rotate Octet Right (3 Bits)
011001  031    ROL      ACC Rotate Octet Left (3 Bits)
011010  032    ADD      ACC += BOP (Carry MCS[CAR])
011011  033    SUB      ACC -= BOP (Borrow MCS[CAR])
011100  034    AND      ACC &= BOP
011101  035    OR       ACC |= BOP
011110  036    XOR      ACC ^= BOP
011111  037    NOT      ACC = ~ACC

//----- 04 Group -----
// Single Stage Barrel Shifter (Shift Mode)
// (Requires Argument: 1, 3, 4, or 6)

1000XY  040-3  SHL      ACC <<= N(XY)
                        00=1,01=3,10=4,11=6

1001XY  044-7  SHR      ACC >>= N(XY)
                        00=1,01=3,10=4,11=6

//----- 05 Group -----
// Incrementors / Decrementors
// (All are in-place up/down counter ops)
// (Requires Argument: ACC, PTR, PSEL, DSEL)

1010XY  050-3  INC      Increment Register
                        00=ACC,01=PTR[PSEL],
                        10=PSEL,11=DSEL

1011XY  054-7  DEC      Decrement Register
                        00=ACC,01=PTR[PSEL],
                        10=PSEL,11=DSEL

//----- 06 Group -----
// Miscellaneous, String, BCD Helpers

110000  060  * SWC      ACC[HCHAR] <=> ACC[LCHAR]
110001  061  * SWO      ACC[OCT3] <=> ACC[OCT2]
110010  062  * BCD      ACC[4:11] = 0
110011  063    ---      RESERVED

// Comparator Operations
110100  064    EQ       MCS[CMP] = (ACC == BOP)
110101  065    NEQ      MCS[CMP] = (ACC != BOP)
110110  066    EZ       MCS[CMP] = (ACC == 0)
110111  067    NEZ      MCS[CMP] = (ACC != 0)

//----- 07 Group -----
// Conditional Relative Jumps
// Bitwise NIP offset calc with generated values
// of NIP += 2, 6, 10, 14. (or -2, -6, -10, -14)
// These require that N2A be executed first to
// pre-load NIP into ACC before JCP or JCN bypass
// BOP and performing ALU ADD or SUB => NIP.
// The formulation of the jump offset word
// may need to be adjusted later.
// b0XY100 produces 4, 12, 20, 28
// bX0Y010 produces 2, 10, 34, 42
// b0X0Y10 produces 2, 6, 18, 22
// (Requires Argument: 2, 6, 10, or 14)

1110XY  070-3  JCP      IF MCS[CMP] NIP += b00XY10

1111XY  074-7  JCN      IF MCS[CMP] NIP -= b00XY10


/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

// Links for Reference:
http://www.learnabout-electronics.org/Digital/images/register-SISO-PISO.gif

// Old (Mostly Outdated) TODO Contents:
- Create bi-directional bus tristate buffer component
- Create up-down counter component (4 bit and 12 bit versions, or 4 bit cascadable)
	- This will be used for the PC, and also the stack sizes
- Create shift registers, some power of 2 size large, possibly 8 or 16
	- This will be used for a 'column' in the stack
- Create stack component.
	- dual-read ported on top two elements.
	- push/pop control lines
	- ability to read size via control line assert
- Create general purpose register
- Create ALU
	- Adder/Subtractor
	- Equality comparator only (no magnitude - yet - 2.0)
	- logical subset
	- negate
	- shift by one +/-
	- special load hex operation - load 4 low bits and shift all others up.
	- char swap - swap low 6 with high 6

- Control unit
	- Instruction register split into opcodes
	- in parallel with hardwired fetch cycle microcode
	- microcode pc counter controls a mux through micro opcodes 
	- two decoders - one for reader and one for writer
		- minimize the number of bus targets
		- ALU inputs hardwired to data stack, and dumps directly
		  back to data bus.  it is the writer in an op.
		- memory unit

- Memory Unit upgrades.
	- three r/w data bus interfaces: PC, AR, MEM
	- state machine between PC control and Addr Reg control.
		- default is latched to PC control
		- override with a write to AR
		- resets after a read or write to MEM
