/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
// 12-Bit MISC CPU Design (Name TBD)

Harvard Architecture
    Single, Pluggable 4K ROM
    One or More 4K RAM Modules, Segmented
    Second Iteration will be a proper Stack Machine

All registers, address and data bus are 12 bits wide
All Opcodes are 6 bits with (mostly) implied operands
    2 opcodes per ROM fetch.
    Microcode sequence is: fetch-exec-exec, repeat
ROM addresses/NIP/jumps point to odd instructions
    May need to fill in NOPs here and there.
    "Big Endian" (in terms of 6-bit chars)

/////////////////////////////////////////////////////
// CPU Diagram

Machine & Bus Layout:
         ___              ___
  [CLK] |   |-[BOP]------|   \---[MCS]--\
     |  |DEC|   ||       |ALU|=\\  || \  \   _
  [INS]-|___|---||-[ACC]-|___/ ||  || |   \=| |==...
    ||       \  ||   ||        ||  || |     | |
    =========|========================|=====|C|==... 
    =========|===== DATA BUS =========|=====|P|==... 
    =========|========================|=====|U|==... 
    ||       |                     || /     | |
  [NIP]------+-------------------[PTR]      |S|
    ||                             ||       |O|
    ========================================|C|==... 
    =============== ADDR BUS ===============|K|==... 
    ========================================|E|==... 
                                            |T|
                                            |_|    

/////////////////////////////////////////////////////
// Devices Attached to Internal Main Data Bus

I    INS    INSTR WORD REG FOR DECODE (WO)
A    ACC    ALU INPUT 1 : A (ACCUMULATOR) (R/W)
B    BOP    ALU INPUT 2 : B (GP/DYADIC) (R/W)
L    ALU    ALU OUTPUT (DIRECT TO BUS) (RO)
C    MCS    MACHINE CTRL/STATUS: CARRY, CMP,
              PSEL, DSEL (R/W)
P    PTR    RAM ADDR REG (R/W) (SELECTABLE ARRAY,
              AUTO INC/DEC on R/W)
N    NIP    ROM ADDR REG (R/W) AKA NIP
S    SKT    PERIPHERAL DEVICE I/O BUS (R/W)
              12 DATA PINS, 12 ADDR PINS
                (Driven by PTR[PSEL] or NIP during FCH)
              3 DSEL PINS
                (Drive chip select on peripherals)
              2 R/W PINS
              ALSO: (GND, VDD, CLK, RST ...)

/////////////////////////////////////////////////////
// CPU socket layout:
Rough Total Pins (From ABove): 33 (div 4 = 8.25)
    Round up to 9 on a side (square chip)
    and include extra GNDs & VDDs, also
    CLK_IN/CLK_OUT
    new total = 9 x 4 = 36

    _|_|_|_|_|_|_|_|_|_
  --|                 |--
  --|                 |--
  --|                 |--
  --|                 |--
  --|      C P U      |--
  --|                 |--
  --|                 |--
  --|                 |--
  --|_________________|--
     | | | | | | | | |

Alternative Rectangular Layout
(Would keep Data Bus on one side
and Address Bus on the other)
36 - 24 = 12 , / 2 = 6

    _|_|_|_|_|_|_
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|   C P U   |--
  --|           |--
  --|           |--
  --|           |--
  --|           |--
  --|___________|--
     | | | | | |

/////////////////////////////////////////////////////
// Inter-Device Transport Notes
ROM to INS is special case
  (Read-Only from ROM to Write-Only for INS)
ALU output is special case (Write-Only to Data Bus)
Accumulator-centric transport instructions
ACC is used for unary operations
BOP is used with ACC for duadic operations
BOP will have a bypass MUX at ALU for ops like
    INC, DEC, JCP

// Special Case Transport
INS <-- SKT     Fetch Instr. hardcoded in 18-bit INS,
                Read line overrides DSEL out to 0
                also overrides ADDR_BUS with NIP out
                NOTE: SKW with DSEL 0 is illegal
ALU --> ACC     Driven by ALU opcodes,
                Implied operands are ACC and BOP

ALU --> NIP     Cond. Relative Jump instruction JCP,
                Overrides BOP before ALU

NIP <-> SKT     Will be necessary for return,
                Drives INC/DEC PTR[PSEL]

ACC <-> SKT     RAM Read/Write or ROM Read, all
                expect manually driving DSEL
                Internal R/W lines auto drive
                INC/DEC of PTR[PSEL]

// Normal Case Transport (Simple Internal Data R/W)
ACC <-> BOP     Swap would be nice, but this is a
                destructive copy 

ACC <-> MCS     Destructive copy, can be used to
                clear CAR, CMP and set PSEL
                and DSEL

ACC <-> PTR     Normal destructive copy

ACC <-> NIP     Actually pretty normal, other than
                the fact that this jumps absolute!
                or else just gets the current NIP

/////////////////////////////////////////////////////
// TODO: 
Name this processor
    DuoFortis, DuoChar, DuoMini, DuoMicro
    SixShooter, DoubleSix
    
Character table with ASCII conversion algorithm
Need to decide on ASCII-to-6bit char mapping

Determine which PTR IDX are auto inc/dec
    and whether on R or W.  stack behavior vs queue
    probably make this a fixed table

Design peripheral interfaces
    ROM expected at address 0
    RAM expected at address 1
    Graphics - Color LCD
        8080 interface. CMD/CTRL
        2 devs possible 12 bit RGB or 9bit 1 dev
    Monochrome Console LCD
        1 dev for cmd & ctrl
    Keyboard
        1 dev: 6 bit low or high char others zero
        parallel interface? look up early apple 1
    Hard Disk
    External RAM
        3 devs: 12 high addr, 12 low addr, 12 data
        2 dev: bit fields mux select, value
    Network
    Bus extender / reducer for interfacing with
        8 to 10 bit hardware: mode addr/data
        1 bus addr -- rising edge triggered
            mode select bit, data apply bit.
        2 bus addrs -- can preserve 12 bits

/////////////////////////////////////////////////////
// Main Board Peripheral Bus (8 Addresses)
// (Board Layout & Design is flexible here)

[Design A - 8K RAM with ext 12 bit peripheral bus]
0    ROM    4K ROM (RO) (PLUGGABLE CARTRIDGE)
1    RAM    4K RAM (R/W)
2    RAM    4K RAM (R/W)
3    ((More RAM? Inter-CPU for multi-core? Network?))
4    KEYB (Parallel Interface -- TBD)
5    LCD (8080 + REGS/MODE -- TBD)
6    BUS_EXT ADDR -- Combine with Data Bus
         for 24-bit address
7    BUS_EXT DATA

[Design B - 16K RAM with ext 10 bit peripheral bus]
0    ROM    4K ROM (RO) (PLUGGABLE CARTRIDGE)
1    RAM    4K RAM (R/W)
2    RAM    4K RAM (R/W)
3    RAM    4K RAM (R/W)
4    RAM    4K RAM (R/W)
5    KEYB (Parallel Interface -- TBD)
6    LCD (8080 + REGS/MODE -- TBD)
7    BUS_EXT ADDR/DATA (2 bit mode, 10 bits data bus)
         writes:
         11xxxxxxxxxx set addr mode, apply data(addr)
         10xxxxxxxxxx set addr mode, do not apply data
         01xxxxxxxxxx set data mode, apply data(data)
         00xxxxxxxxxx set data mode, do not apply data

/////////////////////////////////////////////////////
// Instruction Design Notes -- With Examples

SHL 6  ; Zero out ACC
SHL 6

OC0 7  ; Set ACC to 07777
OC1 7
SHL 6
OC0 7
OC1 7
A2B    ; Store 07777 in BOP

C2A    ; Get MCS to ACC
OC0 0  ; Select return stack pointer
OC1 1  ; Select first RAM bank
A2C    ; Write MCS register

B2A    ; Get 07777 back from earlier
A2P    ; Initialize return stack pointer

// Synthesis of other instructions:
GT and LT comparisons can be synthesized easily
MUL and DIV can be sythesized.  will never be included.

S2A    ; Read some value from RAM or ROM
A2B    ; Copy value into BOP
SHL 1  ; Multiply by 2
ADD    ; Add in BOP, result is "multiply by 3"

// Later Design changes:
single cycle hardware register swap or
 queue would be very useful for ptr/stack/data
also: MUX reg on RAM PTR array.  only exposes
one to the data bus.  Use lower bits of
machine status register. 2 bits for 4 regs:
stack + 3 ptrs -- could be used for call args.

NOTE: ROM needs to be separate and socketable.
An address bus driven by NIP and PTR is necessary,
as well as a bypass on external DSEL.
this would reduce the number of CPU pins by re-using
the address lines for ROM and RAM.  Not shown above
  are the control lines.
FCH bypasses DSEL and asserts 0 on output pins
ADDR output pins are normally driven by PTR[PSEL]
but FCH instructuon overrides this with NIP
NOTE: This also allows PTR access to ROM for reading
fonts, bitmaps, strings, etc... 
  by manually setting DSEL to 0,
  set PTR[PSEL] to desired address and executing IOR.
  This eliminates the need for LBL and frees up an
    8-block of opcodes.

/////////////////////////////////////////////////////
// MCS Register Layout:

Upper two octets R/W are hardwired to ALU in/out.
In this way, the MCS resembles ACC except reversed.
writing ACC => MCS with zero in upper char clears
carry and compare bits.  ADD is always with carry.

 11  10   9 | 8   7   6 | 5   4   3 | 2   1   0
[RES RES CMP|RES RES CAR|   DSEL    |   PSEL   ]

Alternatively, To help simulate ROR and ROL, since
shift operations can handle up to six bits at a
time, use the whole upper character of MCS to
hold the result of the last (applicable) ALU
operation.

 11  10   9 | 8   7   6 | 5   4   3 | 2   1   0
[          RES          |   DSEL    |   PSEL   ]

General / Accumulator Register Layout:

 11  10   9 | 8   7   6 | 5   4   3 | 2   1   0
[  Most Sig | Next-Most | Next-Least| Least Sig ]
[  Octet 3  |  Octet 2  |  Octet 1  |  Octet 0  ]
[  High Char (HCHAR)    |  Low Char (LCHAR)     ]

/////////////////////////////////////////////////////
// PTR[PSEL] Register Bank Behavior
// (One of these can be selected at a time)

PSEL    SKW/N2S      SKR/S2N      Intended Usage

000  0  PTR[PSEL]--  PTR[PSEL]++  Return Stack
001  1  PTR[PSEL]--  PTR[PSEL]++  Data Stack
010  2  PTR[PSEL]++  PTR[PSEL]++  Block Mem Load/Store
011  3  PTR[PSEL]--  PTR[PSEL]--  Block Mem Load/Store
100  4  N/A          N/A          \
101  5  N/A          N/A          | General Purpose
110  6  N/A          N/A          | Pointer Args
111  7  N/A          N/A          / To Subroutines

/////////////////////////////////////////////////////
// Updated Opcodes
*  Will not be in initial implementation
   (Alternative method exists but uses more code)

<Bin>   <Oct>  <Mnem.>  <Descr.>
000000  000    HLT      Halt Execution
000001  001    NOP      No Operation
000010  002    ---      RESERVED
000011  003    FCH      INS = SKT, DSEL => 0,
                        NIP++ driven by read

// NOTE: fetch opcode may be avoidable since this
// can be (probably) more simply built into the main
// micro cycle => drive lines. IE nothing to
// "decode" per se, just do it! That would free up
// this opcode.

// Special Case Transport
// Store NIP in RAM: S2N is return
// Will require auto-inc/dec stack ptr
000100  004    SKW      SKT = ACC, INC/DEC PTR[PSEL]
000101  005    SKR      ACC = SKT, INC/DEC PTR[PSEL]
000110  006  * N2S      SKT = NIP, ++PTR[PSEL],
                            DSEL to 1 ???
000111  007  * S2N      NIP = SKT, PTR[PSEL]--,
                            DSEL to 1 ???

// Normal Transport Operations, ACC Implied.
// 1 bit to/from, 2 bits src/dst
001000  010    A2B      BOP = ACC
001001  011    A2C      MCS = ACC
001010  012    A2P      PTR[PSEL] = ACC
001011  013    A2N      NIP = ACC, Jump Abs!!!
001100  014    B2A      ACC = BOP
001101  015    C2A      ACC = MCS
001110  016    P2A      ACC = PTR[PSEL]
001111  017    N2A      ACC = NIP, Get Instr Ptr

// Arithmetic & Logic Operations
010000  020    ADD      ACC += BOP (Carry MCS[RES]:6)
010001  021    SUB      ACC -= BOP (Borrow MCS[RES]:6)
010010  022    SWP      ACC[HCHAR] <=> ACC[LCHAR]
010011  023    ---      RESERVED
010100  024    AND      ACC &= BOP
010101  025    OR       ACC |= BOP
010110  026    XOR      ACC ^= BOP
010111  027    NOT      ACC = ~ACC

// Comparison Operations
011000  030    EQ       MCS[RES]:6 = (ACC == BOP)
011001  031    NEQ      MCS[RES]:6 = (ACC != BOP)
011010  032    EZ       MCS[RES]:6 = (ACC == 0)
011011  033    NEZ      MCS[RES]:6 = (ACC != 0)

// Incrementors / Decrementors
011100  034    INC      ACC++ (in-place register op)
011101  035    DEC      ACC-- (in-place register op)
011110  036    IPT      PTR[PSEL]++
011111  037    DPT      PTR[PSEL]--    

// Single Stage Barrel Shifter
// (Requires Argument: 1, 3, 4, or 6)
// Shifted-out bits go to MCS[RES] to facilitate
// Simulation of ROR and ROL
1000XY  040-3  SHL      ACC <<= N(XY)
                        00=1,01=3,10=4,11=6
1001XY  044-7  SHR      ACC >>= N(XY)
                        00=1,01=3,10=4,11=6

// Conditional Relative Jumps
// Bitwise NIP offset calc with generated values
// of NIP += 2, 6, 10, 14. (or -2, -6, -10, -14)
// These require that N2A be executed first to
// pre-load NIP into ACC before JCP or JCN bypass
// BOP and performing ALU ADD or SUB => NIP.
// The formulation of the jump offset word
// may need to be adjusted later.
// (Requires Argument: 2, 6, 10, or 14)
1010XY  040-3  JCP      IF MCS[RES]:6 NIP += b00XY10
1011XY  044-7  JCN      IF MCS[RES]:6 NIP -= b00XY10
// b0XY100 produces 4, 12, 20, 28
// bX0Y010 produces 2, 10, 34, 42

// Literal Octet Assignment to Accumulator
// (Requires Argument: 1 through 7) 
110NNN  060-7  OC0      Assign Least Octet to ACC
                        Remainder of ACC left intact
111NNN  070-7  OC1      Assign Next-Least Octet to A
                        Remainder of ACC left intact

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
